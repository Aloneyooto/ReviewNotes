## mysql索引的对比，各自底层数据结构（没写完）

在MySQL中，常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引。？

二叉查找树：左子树键值总小于根的键值，右子树键值总大于根的键值

平衡二叉树（AVL树）：二叉查找树+任意节点的两个子树高度最大差为1

B树:

对于一个**度数**为N的B树，需要保持以下性质：

- 一个节点中的数据量不小于N-1并且不大于2N-1，一个例外就是根节点可以包含小于N-1数量的数据;

- 所有的叶子节点高度相等；

- 在节点中，所有的数据关键字保持递增关系(key[0] < ... < key[size-1])；

- 对于一个孩子节点children[i]，children[i]子树中所有关键大于key[i-1]并且小于key[i] (key[-1]=-∞，key[size]=+∞)。

![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b3539ed31eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

B+树：

定义：

B+树和B树类似，但多了几条规则

- 非叶子结点的子树指针个数与关键字（节点中的元素个数）个数相同
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）
- 所有叶子结点有一个链指针
- 所有关键字都在叶子结点出现
- 只有叶子节点有Data域

特点：

1、是多叉而不是二叉了，使用多叉的目的是降低树的高度;
2、每个节点不再只是存储一个key了，可以存储多个key；
3、非叶子节点存储key，叶子节点存储key和数据。
4、叶子节点两两相连，为顺序查询提供了帮助

![](https://user-gold-cdn.xitu.io/2017/10/25/968a8531aad381eebc041665af8a791a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

InnoDB支持以下几种常见的索引：

- B+树索引

- 全文索引

- 哈希索引

## InnoDB如何实现聚集（聚簇）索引

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

在Innodb中一张表中聚簇索引建立的过程：

1) 有主键时，根据主键创建聚簇索引
2)  没有主键时，会用一个唯一且不允许为空的索引列做为主键，成为此表的聚簇索引
3) 如果表中没有主键或者一个合适的的唯一索引，InnoDB内部会以一个包含行ID值的合成列生成一个隐藏的聚簇索引。表中的行是按照InnoDB分配的ID排序的。行ID是一个6字节的字段，随着一个新行的插入单调增加。因此，行ID顺序物理上是插入顺序。

## 辅助索引的实现机制，与聚簇索引的关系，具体存储的是什么？

辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

![](https://img2018.cnblogs.com/i-beta/1464190/201911/1464190-20191106145143172-1760681728.png)

## 聚簇索引和非聚簇索引的区别

聚簇索引的叶子节点存放的是主键值和数据行，**支持覆盖索引**；二级索引的叶子节点存放的是主键值或指向数据行的指针。

由于节子节点(数据页)只能按照一颗B+树排序，故**一张表只能有一个聚簇索引**。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引

## MyISAM索引实现

MyISAM的索引方式也叫做“非聚集”的。

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。

MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

## MyISAM的应用场景

MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。

## MySQL事务的实现原理（没写完）

事务的特点：

- 原子性：要么全部失败，要么全部成功

  想要保证事务的原子性，就需要在异常发生时，对已经执行的事务进行回滚，这个机制通过回滚日志（undo log）实现，所有事务进行的修改都会先记录到这个回滚日志中。

- 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。

  采用加锁实现。

- 持久性：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。

  事务的持久性也是通过日志来实现的，MySQL使用重做日志实现事务的持久性，重做日志由两方面组成，一是内存中的重做日志缓冲区，它在内存中，是易失的。另一个是在磁盘上的重做日志文件，它是持久的。当需要在一个事务中对数据进行修改时，它会先将数据从磁盘读入内存。并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上。除了所有对数据库的修改会产生重做日志，因为回滚日志也是需要持久存储的，它们也会创建对应的重做日志，在发生错误后，数据库重启时会从重做日志中找出未被更新到数据库磁盘中的日志重新执行以满足事务的持久性。

- 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。

## 锁有哪些？

## 日志有哪些？

- 错误日志：对MySQL启动，运行，关闭过程进行了记录

- 慢查询日志：帮助DBA定位可能存在问题的SQL语句，进行SQL语句层面的优化

- 查询日志：记录所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。

- 二进制日志：记录对MySQL数据库执行更改的所有操作。

  作用：

  - 恢复：某些数据的恢复需要二进制日志

  - 复制：通过复制和执行二进制日志使一台远程的MySQL数据库和一台MySQL数据库进行实时同步

  - 审计：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击

### redo log 重做日志

Redo log可以简单分为以下两个部分：

- 一是内存中重做日志缓冲 (redo log buffer),是易失的，在内存中

- 二是重做日志文件 (redo log file)，是持久的，保存在磁盘中

### 什么时候写Redo?

写入Redo的时机：

- 在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是先修改数据，后写日志

- **redo日志比数据页先写回磁盘**

- 聚集索引、二级索引、undo页面的修改，均需要记录Redo日志。

### Redo的整体流程

第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝

第二步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值

第三步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式

第四步：定期将内存中修改的数据刷新到磁盘中

### undo log 回滚日志

### undo log的定义

undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。

### undo log的作用

undo是一种逻辑日志，有两个作用：

- 用于事务的回滚
- MVCC

关于MVCC(多版本并发控制)的内容这里就不多说了，本文重点关注undo log用于事务的回滚。

undo日志，只将数据库逻辑地恢复到原来的样子，在回滚的时候，它实际上是做的相反的工作，比如一条INSERT ，对应一条 DELETE，对于每个UPDATE,对应一条相反的 UPDATE,将修改前的行放回去。undo日志用于事务的回滚操作进而保障了事务的原子性。

### undo log的写入时机

- DML操作修改聚簇索引前，记录undo日志
- 二级索引记录的修改，不记录undo日志

需要注意的是，undo页面的修改，同样需要记录redo日志。

### undo的存储位置

在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。

