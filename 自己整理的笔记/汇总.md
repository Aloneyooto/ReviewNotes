[TOC]

# 计算机网络

## 7层结构

自底向上分别是:

- 物理层：负责透明传输比特流
- 数据链路层：负责将网络层传下来的IP数据报组装成帧，检测和校正物理层传输介质上产生的传输差错，具体的有PPP，STP
- 网络层：负责为不同主机提供通信服务，网络层的分组数据从源端传到目的端，具体协议有IP,ARP,RARP,ICMP,IGMP等
- 传输层：负责为不同主机中的进程提供通信服务，具体协议有TCP，UDP
- 会话层：允许不同主机上各进程之间的会话
- 表示层：处理在两个通信系统中交换信息的表示方式
- 应用层：为特殊类型的网络应用提供OSI环境手段

## 输入网址后发生了什么

1.解析URL，确定Web服务器和文件名

2.查询服务器域名对应的IP地址：首先查找浏览器上缓存，没有再查找.host文件的缓存，如果没有会发送一个DNS请求给本地DNS域名服务器，本地域名服务器收到请求后如果缓存中的表格能找到则直接返回IP地址，如果没有，则去问根域名服务器。根DNS收到本地DNS的请求后，发现后置是.com。根域名服务器返回本地域名服务器.com顶级域名服务器的地址，本地DNS再去问顶级域名服务器，顶级域名服务器地址告诉本地DNS权威DNS服务器地址，本地DNS再去问就拿到IP地址了。

3.协议栈进行TCP三次握手。TCP模块在执行各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象，接下来网络包在IP头部的前面加上MAC头部（网卡驱动从IP模块获取到包后，将其复制到网卡内的缓存区中，并加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列），网卡将数字信号转换为电信号进行传输，接下来包通过交换机原样转发到目的地，之后到达路由器，并在此被转发到下一个路由器或目标设备。

4.数据包抵达服务器之后，服务器会先查看数据包的MAC头部，查看是否和服务器自己的MAC地址符合，接着继续查看数据包的IP头，发现IP地址符合，根据IP头中的协议项，知道自己上层是TCP协议，接下来查看TCP头部中的序列号，如果是想要的，就放入缓存中然后返回一个ACK，如果不是就丢弃。服务器再根据TCP头部中的端口号，将包发给HTTP进程，最后浏览器获得数据后进行渲染。

## 为什么DNS用udp

https://www.zhihu.com/question/310145373

采用TCP传输，则域名解析时间为：

DNS域名解析时间 = TCP连接时间 + DNS交易时间

采用UDP传输，则域名解析时间为：

DNS域名解析时间 = DNS交易时间

很显然，采用UDP传输，DNS域名解析时间更小。

在很多时候，用户在访问一些冷门网站时，由于DNS服务器没有冷门网站的解析缓存，需要到域名根服务器、一级域名服务器、二级域名服务器迭代查询，直到查询到冷门网站的权威服务器，这中间可能涉及到多次的查询。

如果使用TCP传输，多几次查询，就多几次TCP连接时间，这多出来的时间不容小觑

## 网络协议为什么分层

(1)各层之间是独立的。上一层的工作如何进行并不影响下一层的工作，这样我们在进行每一层的工作[设计](https://www.applysquare.com/fos-cn/design/)时只要保证接口不变可以随意调整层内的工作方式。

(2)灵活性好。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。当某一层出现技术革新或者某一层在工作中出现问题时不会连累到其他层的工作，排除问题时也只需要考虑这一层单独的问题即可。

(3)结构上可分割开。各层都可以采用最合适的技术来实现。技术的发展往往是不对称的，层次化的划分有效避免了木桶效应，不会因为某一方面技术的不完善而影响整体的工作效率。

(4)易于实现和维护。这种结构使得实现和调试一个庞大又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。进行调试和维护时，可以对每一层进行单独的调试，避免了出现找不到问题、解决错问题的情况。

(5)能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。标准化的好处就是可以随意替换其中的某几层，对于使用和科研来说十分方便。

## 什么是TCP/IP协议

TCP/IP协议是指一个由[FTP](https://baike.baidu.com/item/FTP/13839)、[SMTP](https://baike.baidu.com/item/SMTP/175887)、TCP、[UDP](https://baike.baidu.com/item/UDP/571511)、IP等协议构成的协议簇。只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。

## TCP的定义

TCP协议是面向连接的、可靠的、基于字节流的传输层通信协议。

面向连接：使用TCP传输数据前，必须先建立TCP连接；传输完成后再释放连接。

全双工通信:建立TCP连接后，通信双方都能发送数据

可靠：通过TCP连接传送的数据，不丢失，无差错，不重复&&按序到达

面向字节流：数据以流的形式进行传输，TCP一次传输的报文长度有限制，若太大则需分块，分次传输，但由于TCP连接的可靠性，接收方可按顺序接收数据块&重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样。

## TCP头部格式

主要使用的几个选项：

SYN(synchronous)： 发送/同步标志，用来建立连接，和下面的第二个标志位ACK搭配使用。连接开始时，SYN=1，ACK=0，代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中ACK会置为1，代表确认收到连接请求，此时的标志位变成了 SYN=1，ACK=1。

ACK(acknowledgement)：确认标志，表示确认收到请求。

PSH(push) ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；

FIN(finish)：结束标志，用于结束一个TCP会话；

RST(reset)：重置复位标志，用于复位对应的TCP连接。

URG(urgent)：紧急标志，用于保证TCP连接不被中断，并且督促中间层设备尽快处理。

## UDP头部格式

- 16位源端口号
- 16位目标端口号
- 16位包长度
- 16位校验和
- 数据

## TCP粘包（没写完）

TCP 是一个面向字节流的协议，它是性质是流式的，所以它并没有分段。就像水流一样，你没法知道什么时候开始，什么时候结束。

![](https://user-gold-cdn.xitu.io/2018/8/6/1650c8b818748287?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

接收到的是一个报文，它是由发送的两个报文组成的，这样称为粘包。

解决方式：

- 在报文末尾增加换行符表明一条完整的消息，这样在接收端可以根据这个换行符来判断消息是否完整。
- 将消息分为消息头、消息体。可以在消息头中声明消息的长度，根据这个长度来获取报文（比如 808 协议）。
- 规定好报文长度，不足的空位补齐，取的时候按照长度截取即可。

## TCP三次握手

建立TCP连接前：TCP客户端，服务端都处于关闭状态（CLOSED），直到客户端主动打开连接，服务端才被动打开连接（处于监听状态LISTEN）,等待接收客户端的请求。

第一次握手时，客户端向服务器发送1个连接请求的报文段，此报文段同步标志位SYN=1，随机选择一个起始序号seq=x，不携带数据，客户端进入同步已发送状态（SYN_SEND），等待服务器确认。

第二次握手时，服务器收到请求连接的报文段后，若同意建立连接，则向客户端发送连接确认的报文段，该报文段的同步标志位SYN=1，确认标记位ACK=1，随机选择一个起始序号seq=y，确认号字段ack=x+1，不携带数据，服务器进入同步已接收状态（SYN_RCVD）

第三次握手，客户端收到确认报文段后，向服务器再次发出连接确认报文段，该报文段的确认标记位ACK=1，序号seq=x+1，确认号字段ack=y+1，可以携带数据，客户端和服务器端都进入已创建状态(ESTABLISHED)

## 四次挥手过程

释放TCP连接前，TCP客户端和服务器都处于已创建状态(ESTABLISHED)直到客户端主动关闭TCP连接。

第一次挥手时，客户端向服务器发送1个连接释放的报文段，该报文段终止控制位FIN=1，报文段序号为前面传送数据最后1个字节的序号加1，可以携带数据，客户端进入终止等待1状态（FIN-WAIT-1），等待服务器确认。

第二次挥手时，服务器收到连接释放报文段后，则向客户端发回连接释放确认的报文段，该报文段确认标记位ACK=1，报文段序号seq为前面传送数据最后一个字节的序号加1：seq=v，确认号字段设为ack=u+1，此时服务器进入关闭等待状态（CLOSE-WAIT），客户端收到服务器的确认后，进入终止等待2状态(FIN-WAIT-2),等待服务器发出释放连接请求，至此，客户端到服务器的TCP连接已断开，即TCP连接处于半关闭状态，即客户端到服务器的连接断开，服务器到客户端的连接未断开。

第三次挥手时，若服务器已无数据要向客户端发送，则发出释放连接的报文段，该报文段终止控制位FIN=1，确认标记位ACK=1，报文段序号seq=w，重复上次已发送的确认号字段ack=u+1，可以携带数据，服务端进入最后确认状态（LAST-ACK）

第四次挥手时，客户端收到连接释放报文段后，则向服务器发回连接释放确认的报文段，该报文段确认标记位ACK=1，报文段序号seq=u+1，确认号字段ack=w+1，可以携带数据（？），客户端进入时间等待状态（TIME_WAIT），服务器进入关闭状态（CLOSED），此时TCP连接还未释放，须经过时间等待计时器设置的时间2MSL后，客户端才进入连接关闭状态(CLOSED)

## tcp慢开始，为什么指数级别还叫慢开始

虽然窗口是指数增加，但是相比于一开始就选择大窗口，仍然较慢

## 三次握手报文丢失问题

第一次握手丢失：

每次超时时间RTO是指数(翻倍)上涨的，当超过最大重传次数后，客户端不再发送SYN包。在Linux中，第一次握手的SYN超时重传次数，是如下内核参数指定的:

`cat /proc/sys/net/ipv4/tcp_syn_retries`,默认值为5，也就是SYN最大重传次数是5次。

第二次握手丢失：

当第二次握手的SYN，ACK丢包时，客户端会超时重发SYN包，服务端也会超时重传SYN，ACK包。

第三次握手：

在建立TCP连接时，如果第三次握手的ACK，服务端无法收到，则服务端就会短暂处于`SYN_RECV`状态，而客户端会处于`ESTABLISHED	`状态.

由于服务端一直收不到TCP第三次握手的ACK，则会一直重传SYN,ACK包，直到重传次数超过`tcp_synack_retries`值（默认值5次）后,服务端就会断开TCP连接。

而客户端则会有两种情况:

- 如果客户端没发送数据包,一直处于`ESTABLISHED`状态，然后经过2小时11分15秒才可以发现一个死亡连接，于是客户端连接就会断开连接。
- 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过`tcp_retries2`值（默认值15次）后，客户端就会断开TCP连接

## 三次握手初始序列号

大约每4微秒增加1，为了防止序列号猜测攻击

### TCP序列号预测攻击原理（没写）

## TCP为什么是三次握手

主要有三方面的原因：
1.避免历史连接：客户端连续发送多次SYN建立连接的报文，在网络拥堵等情况下：一个旧SYN报文比最新的SYN报文早到达了客户端

## 为什么客户端关闭连接前要等待2MSL时间？

原因1：为了保证客户端发送的最后1个连接释放确认报文能到达服务器，从而使得服务器能正常释放连接。

原因2：防止上文提到的早已失效的连接请求报文出现在本连接中，客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失，即在下一个新的连接中就不会出现早已失效的连接请求报文。

## 拥塞控制

**过程解析**:

阶段1:因cwnd<ssthresh，使用慢开始算法

阶段2：因cwnd>ssthresh,故停止使用慢开始算法而改用拥塞避免算法

阶段3：出现网络拥塞，把慢开始门限（ssthresh）设置为出现拥塞时的发送方窗口值的一半，把拥塞窗口（cwnd）重新设置为1

阶段4：因cwnd<ssthresh，故使用慢开始算法

阶段5：因cwnd>ssthresh，故停止使用慢开始算法而改用拥塞避免算法

注：

a.乘法减小：出现网络拥塞时慢开始门限设置为出现拥塞时的发送方窗口值的一半

b.加法增大：拥塞避免时的缓慢增大

c.二者合并叫为AIMD算法（即加法增大，乘法减少）

目的是为了防止过多的数据注入到网络中。

## 流量控制（没写）

## TCP快速建立连接

![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZctmf3ObkESj41ayTbgy9q4ThRjO0ukiaIPYKAsY8XThOp0f1R4Id6L9icUxj7GUvLica7hmfB9DibG9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 在第一次建立连接的时候，服务端在第二次握手产生一个cookie(已加密)并通过SYN、ACK包一起发给客户端，于是客户端就会缓存这个cookie，所以第一次发起HTTP Get请求的时候，还是需要2个RTT的时延
- 在下次请求的时候，客户端在SYN包带上cookie发给服务端，就提前可以跳过三次握手的过程，因为Cookie中维护了一些信息，服务端可以从Cookie获取TCP相关的信息，这时发起的HTTP GET请求就只需要1个RTT的时延

## TCP和UDP的区别

- TCP是面向连接的，UDP是面向报文的
- TCP传输可靠，UDP传输不可靠
- TCP的传输形式是字节流，UDP的传输形式是数据报文段
- TCP传输效率较慢，UDP传输效率快
- TCP需要的资源多，UDP所需资源少
- TCP主要应用于要求通信数据可靠的场景，UDP主要应用于要求通信速度高的场景

- TCP首部字节为20-60个字节，UDP首部字节为8个字节
- UDP不存在发送缓存

[^什么是short write]: 对于一个非阻塞的TCP套接口，如果其发送缓冲区中根本没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是内核能够拷贝到该缓冲区中的字节数。这个字节数也称为不足计数(应该就是short write的意思)

## TCP确保传输可靠性的方式

TCP协议保证数据传输可靠性的方式主要有:

- 校验和
- 序列号**用来解决网络包乱序问题**

接收方可以去除重复的数据；

接收方可以根据数据包的序列号按序接收；

可以标识发送出去的数据包中，哪些是已经被对方收到的：

- 确认应答**用来解决不丢包的问题**
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

## 有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？

理论值计算公式如下：最大TCP连接数=客户端的IP数X客户端的端口数

对IPv4，客户端的IP数最多为2的32次方，客户端的端口数最多为2的16次方，也就是服务端单机最大TCP连接数，约为2的48次方。

当然，服务端最大并发 TCP 连接数远不能达到理论上限。

- 首先主要是**文件描述符限制**，Socket 都是文件，所以首先要通过 `ulimit` 配置文件描述符的数目；
- 另一个是**内存限制**，每个 TCP 连接都要占用一定内存，操作系统是有限的。