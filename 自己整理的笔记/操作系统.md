[TOC]

# 操作系统

操作系统是管理计算机硬件和软件资源的**计算机程序**。

## 计算机的基本结构

![](https://img-blog.csdnimg.cn/20200111112106718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

## 存储管理

### 层次结构

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/内存结构.png)

操作系统要完成的目标：

![](https://img-blog.csdnimg.cn/20200111112054175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求

在操作系统中管理内存的不同方法：

- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

地址空间：

- 物理地址空间：硬件支持的地址空间
- 逻辑地址空间：一个运行的程序所拥有的内存范围

逻辑地址如何转换成物理地址：

=>CPU方面  
a.运算器ALU需要在逻辑地址的内存内容(CPU要逻辑地址)  
b.内存管理单元MMU寻找在逻辑地址和物理地址之间的映射(然后MMU找逻辑和物理地址的关系)  
c. 控制器从总线发送在物理地址的内存内容的请求(关系找到后，去找对应物理地址)  
=>内存方面  
e.内存发送物理地址内存内容给CPU(物理地址找到了，给CPU)  
=>操作系统方面  
f.建立逻辑地址和物理地址之间的映射(确保程序不相互干扰)

### 内存分配

- 单一连续分配：最简单，只能在单用户，单进程的系统中使用，将内存分成系统区和用户区
- 固定分区分配：支持多道程序的最简单存储分配方式，将内存空间划分为若干固定大小的区域，每个分区只提供给一个程序使用。
- 动态分区分配：根据进程实际需要，动态分配内存空间

#### 内存碎片

内存碎片：空闲内存不能被利用

- 外部碎片：在分配单元间的未使用内存
- 内部碎片：在分配单元中的未使用内存

**简单的内存管理方法**：

- 当一个程序准许运行在内存中时，分配一个连续的区间
- 分配一个连续的内存区间给运行的程序以访问数据

#### 动态分区分配 - 具体分配算法

**基于顺序分配**：

- 首次适应算法(FF算法)：
  从开始顺序查找适合空闲区，若没有合适的空闲区，则该次分配失败（主要使用空闲链）

  优点：简单，易于产生更大空闲块，向着地址空间的结尾

  缺点：头部地址不断被划分，容易产生外部碎片

- 最佳适应算法(BF算法)：
  空闲区链表按容量大小排序，每次遍历空闲区链表找到最佳合适空闲区

  优点：当大部分分配时小尺寸时非常有效，比较简单

  缺点：容易产生大量容量小的外部碎片，重分配的速度慢

- 最坏适应算法(WF算法)

  扫描整个空闲分区表或链表，挑选最大的空闲区使用。

  优点：假如分配是中等尺寸效果最好

  缺点：重分配慢，易于破碎大的空闲块以致大分区无法被分配

**基于索引分配：**

- 快速适应算法(QF算法)
  有多个空闲区链表，每个存储一种容量的空闲区

**压缩式碎片整理**：

- 重制程序以合并孔洞
- 要求所有程序是 动态可重置的
- 问题：何时重置；开销

![](https://img-blog.csdnimg.cn/20200112131044601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

**交换式碎片整理**：

- 运行程序需要更多的内存
- 抢占等待的程序或回收它们的内存(把暂时不用的内容挪到磁盘里

![](https://img-blog.csdnimg.cn/20200112131117171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

#### 非连续空间内存分配

**连续内存分配的缺点**：

- 分配给一个程序的物理内存是连续的
- 内存利用率较低
- 有外碎片，内碎片的问题

**非连续分配的优点**：

- 分配给一个程序的物理内存是非连续的
- 更好的内存利用和管理
- 允许共享代码和数据(共享库等)
- 支持动态加载和动态链接

**缺点：**

- 如何建立虚拟地址和物理地址之间的转换

##### 分段

**分段寻址方案**：

段访问机制：一个段指一个“内存块”，是一个逻辑地址空间。程序根据段访问机制访问内存地址需要一个二维的二元组(s**段号**，addr**段内偏移**)

两种方式：

![](https://img-blog.csdnimg.cn/20200112152918480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

硬件实现：

![](https://img-blog.csdnimg.cn/20200112152938108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

段号就是段表里的编号，通过查询段表可以得到起始地址和段的限制范围，如果偏移量不在这个范围内，就会抛出异常。

##### 分页

划分物理内存至固定大小的帧，划分逻辑地址空间至相同大小的页。

建立方案 转换逻辑地址为物理地址：

- 页表
- MMU/TLB

页帧：**物理内存**被分割为大小相等的帧

![](https://img-blog.csdnimg.cn/20200112152953827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

页：**逻辑地址空间**被划分为大小相等的页

页寻址机制：

页表实际上就是一个大的数组/hash表。它的index是 页号，对应的value是 页帧号，首先根据逻辑地址计算得到一个 页号，也就是index，再在页表中找到对应的 页帧号，最后根据 页帧号 计算得到物理地址；由于他们的页/帧内偏移相等，所以页表不需要保存这个数据。通过这种方式能够根据逻辑地址找到对应的物理地址。

![](https://img-blog.csdnimg.cn/20200112153045773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3YW5kZXJ1,size_16,color_FFFFFF,t_70)

**页表**:



### 内存回收

四种情况：

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/内存回收情况1.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/内存回收情况2.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/内存回收情况3.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/内存回收情况4.png)

### 段页式存储管理

**页式存储管理**：

页面是一个相对逻辑空间的定义。

将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小相等的物理块，以页面为单位把进程空间装进物理内存中分散的物理块。

页面大小应该适中，过大难以分配，过小内存碎片过多。一般是512B-8K

页表记录进程逻辑空间与物理空间的映射。

有一段连续的逻辑分布在多个页面中，将大大降低执行效率。

**段式存储管理**：

将进程逻辑空间划分成若干段（非等分），段的长度由连续逻辑的长度决定。

**段页式存储管理**：

先将逻辑空间按段式管理分成若干段，再把段内空间按页式管理等分成若干页。

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/地址表示方式.png)

### 虚拟内存

程序运行时，无需全部装入内存，装载部分即可。如果访问页不在内存，则发出缺页中断，发起页面置换。

#### 置换算法

（去看看组成原理部分有没有这个）
##### 先进先出算法（FIFO）

##### 最不经常使用算法（LFU）

##### 最近最少使用算法（LRU）


高速缓存的替换时机：缓存没有数据，需要从主存载入数据

主存页面的替换时机：主存缺页的时候，需要从辅存载入页面数据

替换策略发生在Cache-主存层次，主存-辅存层次。

Cache-主存层次的替换策略主要是为了解决速度问题，主存-辅存层次主要是为了解决容量问题。

### Linux的存储管理

#### Buddy内存管理算法

主要为了解决内存外碎片的问题。

页内碎片：已经分配出去的内存空间 - 请求所需的内存空间

页外碎片：还没被分配但无法分配

内存分配原则：向上取整为2的幂大小

伙伴系统：一片连续内存的“伙伴”是相邻的另一片大小一样的连续内存。

流程：

创建一系列的空闲块链表，每一种都是2的幂。

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/buddy内存管理算法1.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/buddy内存管理算法2.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/buddy内存管理算法3.png)

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/buddy内存管理算法4.png)

#### Linux交换空间

linux物理内存满时，会把一些内存交换至Swap空间。

主要用途：

- 冷启动内存依赖
- 系统睡眠依赖
- 大进程空间依赖


## 进程管理

### 进程实体

为什么需要进程？

- 进程是系统进行资源分配和调度的基本单位
- 进程作为程序独立运行的载体保障程序正常执行
- 进程的存在使得操作系统资源的利用率大幅提升

#### 主存中的进程形态

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/进程控制块.png)

- 标识符：唯一标记一个进程
- 状态：标记进程的进程状态
- 程序计数器：进程即将被执行的下一条指令的地址
- 内存指针：程序代码，进程数据相关指针
- 上下文数据：进程执行时处理器存储的数据
- IO状态信息：被进程IO操作所占用的文件列表
-  记账信息：使用处理器时间，时钟数总和等

**进程控制块**：

- 用于描述和控制进程运行的通用数据结构
- 记录进程当前状态和控制进程运行的全部信息
- PCB使得进程是能够独立运行的基本单位
- PCB是常驻内存的，存放在系统专门开辟的PCB区域内。

### 进程状态

- 就绪状态：其他资源都准备好，只差CPU资源的状态
- 执行状态：进程获得CPU，其程序正在执行
- 阻塞状态：进程因某种原因放弃CPU的状态
- 创建状态：创建进程时拥有PCB但其他资源尚未就绪的状态
- 终止状态：进程结束由系统清理或者归还PCB的状态

### 进程同步

原则：

- 空闲让进
- 忙则等待
- 有限等待
- 让权等待

方法：

- 消息队列
- 共享存储
- 信号量

### 线程同步的方法

#### 互斥量

保证两个线程的指令可以先后执行。

互斥量（互斥锁），处于两态之一的变量：解锁和加锁，两个状态可以保证资源访问的串行。

java中采用ReetrantLock实现。

#### 读写锁

特殊的自旋锁，允许多个读者同时访问资源，对于写操作则互斥。

#### 自旋锁

使用自旋锁的线程会反复检查锁变量是否可用。自旋锁不会让出CPU，是一种忙等待状态。

避免进程或线程上下文切换的开销，不适合在单核CPU使用。

#### 条件变量

条件变量允许线程睡眠，直到满足某种条件，当满足条件时，可以向该线程发送信号，通知唤醒。

**使用fork系统调用创建进程**：

fork系统调用是用于创建进程的，fork创建的初始化状态与父进程一样，系统会为fork的进程分配新的资源。

fork系统调用无参数，会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。

fork()后，父子进程变量地址一致：

子进程“继承”父进程的变量，其地址总是一样的，因为在fork时整个虚拟地址空间被复制，但是虚拟地址空间所对应的物理内存却没有复制（这个时候父子进 程中变量 x对应的虚拟地址和物理地址都相同）。等到虚拟地址空间被写时，对应的物理内存空间被复制（这个时候父子进程中变量 i 对应的虚拟地址还是相同的，但是物理地址不同），也就是"写时复制"。

### 进程同步的方法

共享内存：两个进程之间共享和传递数据最快的方式，共享存储允许不相关的进程访问同一片物理内存，**未提供同步机制**，需要借助其他机制管理访问。

使用步骤：

- 申请共享内存
- 连接到进程空间
- 使用共享内存
- 脱离进程空间&删除

### linux的进程管理

- 前台进程：具有终端，可以和用户交互
- 后台进程：没有占用终端，基本不和用户交互，优先级比前台进程低
- 守护进程：进程名字以d结尾的一般都是守护进程

#### 进程的标记

- 进程ID：进程的唯一标记，一个非负整数，父子进程关系可以通过pstree命令查看
ID为0的进程为idle进程，是系统创建的第一个进程
ID为1的进程是init进程，是0号进程的子进程，完成系统初始化
init进程是所有用户进程的祖先进程
- 进程的状态标记

#### 操作linux进程的有关命令

- ps命令：列出当前进程
`ps -aux`：打印进程详细信息
- top命令：查看系统内进程动态
- kill命令：发送指定信号给进程
`kill -l`查看操作系统支持的信号

## 作业管理

### 进程调度

进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权。

两个步骤：

- 保留旧进程的运行信息
- 选择新进程，准备运行环境并分配CPU

三个机制：

- 就绪队列的排队机制：将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程
- 选择运行进程的委派机制：调度程序以一定策略选择就绪进程，将CPU资源分配给它
- 新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文

按照老进程是否执行完毕，进程调度分为：

- 非抢占式的调度：处理器一旦分配给某个进程，就让该进程一直使用下去，调度程序不以任何原因抢占正在被使用的处理器，直到进程完成工作或因为IO阻塞才会让出处理器
- 抢占式的调度：允许调度程序以一定的策略暂停当前运行的进程，保存好旧进程的上下文信息，分配处理器给新进程

二者的比较：

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/进程调度方式的比较.png)

#### 进程调度算法

- 先来先服务：在就绪队列内按照先来先服务的原则先取出队列前面的进程进行调度
- 短进程优先：调度程序优先选择就绪队列中估计运行时间最短的进程，不利于长作业进程的进行
- 高优先权优先：调度程序优先选择权重高的进程，使得紧迫的任务可以优先处理
- 时间片轮转：按先来先服务的原则排列就绪进程，每次从队列头部取出待执行进程，分配一个时间片执行，相对公平，但不能保证及时响应用户。

### 死锁

两个或两个以上的进程在执行过程中由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。

#### 产生

- 竞争资源：共享资源数量不满足各个进程的需求
- 进程调度顺序不当

#### 四个必要条件

- 互斥条件：进程对资源的使用是排他性的使用
- 请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源
- 不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺，获得的资源只能由进程自身释放
- 环路等待条件：发生死锁时，必然存在进程-资源环形链

#### 处理

**预防死锁的方法**：

- 破坏请求保持条件：系统规定进程运行之前，一次性申请所有需要的资源。
- 破坏不可剥夺条件：当一个进程请求新的资源得不到满足时，必须释放占有的资源
- 破坏环路等待条件：可用资源线性排序，申请必须按照需要递增申请

**银行家算法**：

是一个可操作的著名的避免死锁的算法，以银行借贷系统分配策略为基础的算法。

基础有三个表：已分配资源表，所需资源表，可分配资源表



## 文件管理

### 文件的逻辑结构

#### 逻辑结构的文件类型

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/逻辑结构的文件类型.png)

有结构文件：文件内容由定长记录和可变长记录组成，定长记录存储文件格式，文件描述等结构化数据项。可变长记录存储文件具体内容。

无结构文件（流式文件）：文件内容长度以字节为单位（exe文件，dll文件，so文件）

#### 顺序文件

顺序文件是指按顺序存放在存储介质中的文件

#### 索引文件

目的：解决可变长文件存储
需要配合索引表完成存储。

### 辅存的存储空间分配

#### 辅存的分配方式

**连续分配**：

按顺序分配文件。

优点：顺序读取文件内容非常容易，速度很快

缺点：对存储要求高，要求满足容量的连续存储空间

**链接分配**：

可以将文件存储在离散的盘块中，但需要额外的存储空间存储文件的盘块链接顺序。

- 隐式链接：下一个链接指向存储在当前盘块内，适合顺序访问，随机访问效率很低。可靠性差。
- 显式链接：使用FAT表存储下一个盘块地址，缺点是不支持高效的直接存储（FAT记录项多），检索FAT表需要较大的存储空间（需要将整个FAT加载到内存）

**索引分配**：

把文件的所有盘块集中存储（索引），读取某个文件时，将文件索引读取进内存即可。

每个文件拥有一个索引块，记录所有盘块的信息。

索引分配方式支持直接访问盘块，文件较大时具有明显的优势。

#### 存储空间管理

- 空闲表
	`序号 | 第一个空闲盘块号 | 空闲盘块数`
- 空闲链表:
	空闲链表法把所有空闲盘区组成一个空闲链表，每个链表节点存储空闲盘块和空闲数目。
- 位示图

	优点：
	
	- 位示图维护成本很低
	- 可以非常容易找到空闲盘块
	- 占用空间很小

### Linux文件基本操作

#### Linux目录

`/bin`:可执行的二进制文件
`/etc`:系统管理和配置文件
`/home`：用户主目录
`/usr`：系统应用目录
`/usr/local`：管理员安装的软件的目录
`/proc`：虚拟文件系统的目录
`/dev`：Linux设备文件
`/boot`：系统引导时用的文件
`/lib`：系统启动或运行时需要的一些动态库文件

#### 简单的文件操作

创建文件:`touch 文件名` `vim 文件名`
查看文件：`cat 文件名`
删除文件：`rm 文件名`
创建文件夹：`mkdir 文件夹名`

#### 文件类型

普通文件: `-`
目录文件:`d`
符号链接:`l`
套接字:`s`
设备文件:`b,c`
FIFO:`p`

### 文件系统

FAT(File Allocation Table)：FAT16，FAT32等，微软Dos/Windows使用的文件系统。使用一张表保存盘块的信息。

NTFS(New Technology File System):WindowsNT环境的文件系统

EXT(Extended file system)：扩展文件系统，Linux文件系统

**EXT文件系统**：

Boot Sector：启动扇区，安装开机管理程序
Block Group：块组，存储数据的实际位置

![](https://yueqilai-images.oss-cn-beijing.aliyuncs.com/EXT文件系统.png)

`Inode Table`：存放文件Inode的地方，每一个文件（目录）都有一个node，是每一个文件（目录）的索引节点

`Inode`:

- 文件类型
- 文件权限
- 文件物理地址
- 文件长度
- 文件连接计数
- 文件存取时间
- 文件状态
- 索引节点编号
- 访问计数
- 链接指针

文件名不是存放在Inode节点上的，而是存放在目录的Inode节点，列出目录文件的时候无需加载文件的Inode

`Inode bitmap`：Inode的位示图，记录已分配的Inode和未分配的Inode

`Data block`：存放文件内容，每个block都有唯一的编号，文件的block记录在文件的Inode上。

`Block bitmap`：记录Data Block的使用情况

`Superblock`：记录整个文件系统相关信息的地方，包括block和Inode的使用情况，时间信息，控制信息等。

## 设备管理

### IO设备的缓冲区

减少CPU处理IO请求的频率，提高CPU与IO设备之间的并行性。

### SPOOLing技术

是关于慢速字符设备如何与计算机主机交换信息的一种技术。利用高速共享设备将低速的独享设备模拟为高速的共享设备。

在输入，输出之间增加了排队转储环节（输入井，输出井），SPOOLing负责输入（出）井与低速设备之间的调度。

逻辑上，系统为每一个用户都分配了一台独立的高速独享设备。进程直接与高速设备交互，减少了进程的等待时间。